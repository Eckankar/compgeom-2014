\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage[vlined, ruled, linesnumbered]{algorithm2e}

\title{Computational Geometry - Geometric Data Structures}
\author{Philip Munksgaard \\ Sebastian Paaske Tørholm \\ Ejnar Håkonsen}

\begin{document}
\maketitle

\section{Exercise 10.1}
\subsection{Pseudocode}
\begin{algorithm}[H]
	\caption{\FuncSty{BuildExerciseTree(}$lines$\FuncSty{)}}

	\SetKwFunction{BuildRangeTree}{Build1DRangeTree}
	\SetKwFunction{ConstructIntervalTree}{ConstructIntervalTree}
    \SetKwFunction{CanonicalSubset}{CanonicalSubset}
    \SetKwFunction{Assoc}{Assoc}
	\SetArgSty{}

    $ys \leftarrow $ y-coordiates of $lines$\;
    $\mathcal{T} \leftarrow \BuildRangeTree(ys)$\; 
    \ForEach{$node \in \mathcal{T}$}{
        $ps \leftarrow $ points associated with $\CanonicalSubset(node)$\;
        $\Assoc(node) \leftarrow \ConstructIntervalTree(ps)$\;
    }

    \Return{$\mathcal{T}$}\;
\end{algorithm}

\begin{algorithm}[H]
    \SetKwData{lines}{lines}

    \caption{\FuncSty{QueryExerciseTree(}$\mathcal{T},x,[y_1 : y_2]$\FuncSty{)}}
	
	\SetKwFunction{RangeQuery}{1DRangeQuery}
	\SetKwFunction{QueryIntervalTree}{QueryIntervalTree}
    \SetKwFunction{Assoc}{Assoc}
    \SetKwFunction{ReportAll}{ReportAll}
	\SetArgSty{}

    $nodes \leftarrow \RangeQuery(\mathcal{T}, [y_1 : y_2])$\; 

    \ForEach{$node \in nodes$}{
        $\ReportAll(\QueryIntervalTree(\Assoc(node), x))$\;
    }
\end{algorithm}

\subsection{Correctness}
% TODO

\subsection{Resource usage}
Since interval trees take up $O(n)$ space, we can use the same argument as is used
in lemma 5.6 to conclude that the range tree with associated interval trees takes up
$O(n \log n)$ space.

Constructing the outer range tree takes $O(n \log n)$. On each level, we construct a
number of interval trees with cost $O(k_i \log k_i)$, with $\sum k_i = n$. The sum of
the costs on each such level is bounded by $O(n \log n)$, and we have $\log n$ levels,
giving us a total construction cost of $O(n \log^2 n)$.

Querying the range tree costs $O(\log n)$, giving a list of length $O(\log n)$
subtrees. For each of these returned elements, we do a $O(\log n + k_i)$ query
against the associated interval tree, with $\sum k_i = k$ being the number of
found line segments. This gives a total of $O(\log^2 n + k)$.

\section{Exercise 10.6}

\subsection{Using segment trees}

We use a modified segment tree. At each node, however, instead of
saving the canonical subsets in each node, we save only the size of
the canonical subset. That way, we achieve $O(n)$ size, and we can
query the tree in the same manner as in \verb+QuerySegmentTree+, only
reporting the size of the canonical subset instead of the canonical
subset itself.

\section{Exercise 10.9}

\section{Exercise 10.10}

\end{document}

