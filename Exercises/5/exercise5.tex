\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage[vlined, ruled, linesnumbered]{algorithm2e}

\title{Computational Geometry - Geometric Data Structures}
\author{Philip Munksgaard \\ Sebastian Paaske Tørholm \\ Ejnar Håkonsen}

\begin{document}
\maketitle

\section{Exercise 10.1}
\subsection{Pseudocode}
\begin{algorithm}[H]
	\caption{\FuncSty{BuildExerciseTree(}$lines$\FuncSty{)}}

	\SetKwFunction{BuildRangeTree}{Build1DRangeTree}
	\SetKwFunction{ConstructIntervalTree}{ConstructIntervalTree}
    \SetKwFunction{CanonicalSubset}{CanonicalSubset}
    \SetKwFunction{Assoc}{Assoc}
	\SetArgSty{}

    $ys \leftarrow $ y-coordiates of $lines$\;
    $\mathcal{T} \leftarrow \BuildRangeTree(ys)$\; 
    \ForEach{$node \in \mathcal{T}$}{
        $ps \leftarrow $ points associated with $\CanonicalSubset(node)$\;
        $\Assoc(node) \leftarrow \ConstructIntervalTree(ps)$\;
    }

    \Return{$\mathcal{T}$}\;
\end{algorithm}

\begin{algorithm}[H]
    \SetKwData{lines}{lines}

    \caption{\FuncSty{QueryExerciseTree(}$\mathcal{T},x,[y_1 : y_2]$\FuncSty{)}}
	
	\SetKwFunction{RangeQuery}{1DRangeQuery}
	\SetKwFunction{QueryIntervalTree}{QueryIntervalTree}
    \SetKwFunction{Assoc}{Assoc}
    \SetKwFunction{ReportAll}{ReportAll}
	\SetArgSty{}

    $nodes \leftarrow \RangeQuery(\mathcal{T}, [y_1 : y_2])$\; 

    \ForEach{$node \in nodes$}{
        $\ReportAll(\QueryIntervalTree(\Assoc(node), x))$\;
    }
\end{algorithm}

\subsection{Correctness}
By correctness of range tree querying, any line that isn't returned by the query
to the range tree must have an y-coordinate outside of the interval $[y_1 : y_2]$.
Since such a line cannot cross our query line, such a line shouldn't be reported.

Furthermore, any line returned by the range query will have $y \in [y_1 : y_2]$,
and that each such line will be contained in precisely one of the reported subtrees.

By correctness of interval trees, we know that each interval belonging to the tree,
containing the queried $x$ coordinate, is reported precisely once. Since furthermore
each line corresponds to one interval, and is contained in precisely one interval tree
\footnote{By virtue of belonging to precisely one subtree in the range tree.}, we know
that each line segment with $y \in [y_1 : y_2]$, intersecting $x$, will be reported
exactly once, which was what was desired.

\subsection{Resource usage}
Since interval trees take up $O(n)$ space, we can use the same argument as is used
in lemma 5.6 to conclude that the range tree with associated interval trees takes up
$O(n \log n)$ space.

Constructing the outer range tree takes $O(n \log n)$. On each level, we construct a
number of interval trees with cost $O(k_i \log k_i)$, with $\sum k_i = n$. The sum of
the costs on each such level is bounded by $O(n \log n)$, and we have $\log n$ levels,
giving us a total construction cost of $O(n \log^2 n)$.

Querying the range tree costs $O(\log n)$, giving a list of length $O(\log n)$
subtrees. For each of these returned elements, we do a $O(\log n + k_i)$ query
against the associated interval tree, with $\sum k_i = k$ being the number of
found line segments. This gives a total of $O(\log^2 n + k)$.

\section{Exercise 10.6}

\subsection{Using segment trees}

We use a modified segment tree. At each node, however, instead of
saving the canonical subsets in each node, we save only the size of
the canonical subset. That way, we achieve $O(n)$ size, and we can
query the tree in the same manner as in \verb+QuerySegmentTree+, only
reporting the size of the canonical subset instead of the canonical
subset itself.

\section{Exercise 10.9}

\section{Exercise 10.10}

\end{document}

